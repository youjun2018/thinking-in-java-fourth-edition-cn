# 第2章  一切都是对象

## 2.1 用引用操纵对象

一切都被视为对象，因此可采用单一固定的语法。尽管一切都<font face="楷体">看做</font>对象，但操纵的标识符实际上是对象的一个“引用”(reference)。

可以想象成用遥控器（引用）来操纵电视机（对象）。控制住遥控器，就能保持和电视机的连接。想改变电视机的音量大小，实际操纵的是遥控器，由遥控器来操纵电视机。

此外，即使没有电视机，遥控器亦可独立存在。也就是说，你拥有一个引用，并不一定需要一个对象与它关联。

## 2.2 必须由你创建所有对象

Java 提供了大量过剩的现成类型。

### 2.2.1 存储到什么地方

1. **寄存器**。 这是最快的存储区 p22

2. **堆栈**。 位于通用RAM

3. **堆**。 一种通用的

4. **常量存储**。 常量

5. **非RAM存储**。 非RAM存储


### 2.2.2 特例：基本类型

Java 中的“基本”类型，不用NEW来创建变量，而是创建一个<font face="楷体">并非是引用</font>的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。

Java 要确定每种基本类型所占存储空间的大小。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。

P23

| 基本类型 | 大小 | 最小值 | 最大值 | 包装器类型 |
|---|---|---|---|---|
|**boolean**|-|-|-|**Boolean**|
|**char**|16-bit|||**Character**|
|**byte**|8 bits|||**Byte**|
|**short**|16 bits|||**Short**|
|**int**|32 bits|||**Integer**|
|**long**|64 bits|||**Long**|
|**float**|32 bits|||**Float**|
|**double**|64 bits|||**Double**|
|**void**|-|-|-|**Void**|

所有数值类型都有正负号，所以不要去寻找无符号的数值类型。

**boolean** 类型所占存储空间的大小没有明确指定，仅定义为能够取字面值 **true** 或 **false**。

**高精度数字**

Java 提供两个用于高精度计算的类：**BigInteger** 和 **BigDecimal**。虽然大体上属于“包装器类”的范畴，但二者都没有对应的基本类型。

必须以方法调用的取代运算符来实现基本操作。由于复杂了许多，所以运算速度比较慢，但是这里以速度换取了精度。

**BigInteger** 支持任意精度的整数。也就是说，在运算中，可以准确地表示任何大小的整数值，而不会丢失任何类型。

**BigDecimal** 支持任何精度的定点数，例如，可以用它进行精确的货币计算。

关于调用这两个类的构造器和方法的详细信息，请查阅 JDK 文档。

### 2.2.3 Java 中的数组

在 C/C++ 中使用数组是很危险的，因为 C 和 C++ 中数组就是内存块。Java 确保数组会被初始化，而且不能在它的范围之外被访问。

当创建一个数组对象时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字 **null**。一旦Java看到 **null**，就知道这个引用还没有指向某个对象。在使用任何引用前，必须为其指定一个对象；如果试图使用一个还是 **null** 的引用，在运行时就会报错。因此，常犯的数组错误在 Java 中就可以避免。

还可以创建用来存放基本数据类型的数组。

## 2.3 永远不需要销毁对象
### 2.3.1 作用域

大多数过程型语言都有<font face="楷体">作用域(scope)</font>的概念。作用域决定了在其内定义的变量名的可见性和生命周期。在C、C++和java中，作用域由花括号的位置决定。

尽管一下代码在 C 和 C++ 中是合法的，但是在 Java 中却<font face="楷体">不能</font>这样书写。
```Java
{
  int x = 12;
  {
    int x = 96;  // Illegal
  }
}
```
编译器将会报告变量 x 已经定义过。所以在 C 和 C++ 里将一个较大作用域的变量“隐藏”起来的做法，在 Java 里是不允许的。因为 Java 设计者认为这样做会导致程序混乱。

### 2.3.2 对象的作用域

当 **new** 创建一个 Java 对象时，它可以存活于作用域之外。

Java 有一个<font face="楷体">垃圾回收器</font>，用来监视用 **new** 创建的所有对象，并分辨哪些不会再被引用的对象。随后释放这些对象的内存空间，以便供其他新的对象使用。这样做就消除了这类编程问题（即“内存泄漏”），这是由于程序员忘记释放内存而产生的问题。

## 2.4 创建新的数据类型：类
```Java
class ATypeName {  /* Class body goes ther */  }
```

### 2.4.1 字段和方法

类中设置两种类型的元素：<font face="楷体">字段</font>（有时被称作<font face="楷体">数据成员</font>）和 <font face="楷体">方法</font>（有时被称作<font face="楷体">成员函数</font>）。如果字段是某个对象的引用，那么必须初始化该引用，以便使其与一个实际的对象（如前所述，使用**new**来实现）相关联。

想修改的数据也有可能位于对象所包含的其他对象中。在这种情况下，只需要再使用连接句点即可。例如：



```Java
myPlane.leftTank.capacity = 100;
```


**基本成员默认值**

若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它会获得一个默认值，如下表所示：



|基本类型|默认值|
|----|----|
|**boolean**|**false**|
|**char**|**'\u0000'(null)**|
|**byte**|**(byte)0**|
|**short**|**(short)0**|
|**int**|**0**|
|**long**|**0L**|
|**float**|**0.0f**|
|**double**|**0.0d**|



当变量<font face="楷体">作为类的成员</font>使用时，Java 才确保给定其默认值，以确保那些是基本类型的成员变量得到初始化(C++没有此功能)，防止产生程序错误。但是这些初始值对你的程序来说，可能是不正确的，甚至是不合法的。所以最好明确地对变量进行初始化。

然而上述确保初始化的方法并不适用于“局部”变量（即并非某个类的字段）。因此如果在某个方法定义中有



```Java
int x;
```



那么变量x得到的可能是任意值（与 C 和 C++ 中一样），而不会被自动初始化为零。

## 2.5 方法、参数和返回值

在 Java 里却常用<font face="楷体">方法</font>这个术语来表示“做某些事情的方式”。

Java 的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称、参数、返回值和方法体。下面是它最基本的形式：



```Java
ReturnType methodName( /* Argument list */ ) {
  /* Method body */
}
```



**方法名和参数列表（它们合起来被称为“方法签名”）唯一地标识出某个方法。**

Java 中的方法只能作为类的一部分来创建。方法只有通过对象才能被调用，并且这个对象必须能执行这个方法调用。



```Java
int x = a.f();
```



这种调用方法的行为通常被称为<font face="楷体">发送消息给对象</font>。在上面的例子中，消息是 **f()**，对象是 **a**。面向对象的程序设计通常简单地归纳为“向对象发送消息”。


### 2.5.1 参数列表

像Java中任何传递对象的场合一样，这里传递的实际上也是引用，并且引用的类型必须正确。

注：对于前面所提到的特殊数据类型 **boolean**、**char**、**byte**、**short**、**int**、**long**、**float** 和 **double** 来说是一个例外。通常，尽管传递的是对象，而实际上传递的是对象的引用。


## 2.6 构建一个 Java 程序

### 2.6.1 名字可见性

Java 包名都是小写。

这种机制意味着所有的文件都能够自动存活于它们自己的名字空间内，而且同一个文件内的每个类都有唯一的标识符 -- Java 语言本身已经解决了这个问题。

### 2.6.2 运用其他构件

**import** 指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包括类，还可能包括方法和数据；但是 Java 中所有的代码都必须写在类里）。



```Java
import java.util.ArrayList;

import java.util.*;
```



这种一次导入一群类的方式比一个一个地导入类的方式更常用。


### 2.6.3 static 关键字

通常来说，当创建类时，就是在描述那个类的对象的外观与行为。除非用 **new** 创建那个类的对象，否则，实际上并未获得任何对象。执行 **new** 来创建对象时，数据存储空间才被分配，其方法才供外界调用。

有两种情形用上述方法是无法解决的。一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。而另一种情形是，希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使没有创建对象，也能够调用这个方法。

通过 **static** 关键字可以满足这两方面的需求。当声明一个事物是 **static** 时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的任何对象，也可以调用其 **static** 方法或访问其 **static** 域。通常，你必须创建一个对象，并用它来访问数据或方法。因为非 **static** 域和方法必须知道他们一起运作的特定对象。

注：当然，由于在用 static 方法前不需要创建任何对象；所以对于 static 方法，不能简单地通过调用其他非 static 域或方法而没有指定某个命名对象，来直接访问非 static 域或方法（因为非 static 域或方法必须与某一特定对象关联）。

有些面向对象语言采用<font face="楷书">类数据</font> 和 <font face="楷书">类方法</font>两个术语，代表那些数据和方法只是作为整个类，而不是类的某个特定对象而存在的。有时，一些 Java 文献里也用到这两个术语。

只需将 **static** 关键字放在定义之前，就可以将字段或方法设定为 **static**。

**使用类名是引用 static 变量的首选方式，这不仅是因为它强调了变量的 static 结构，而且在某些情况下它还为编译器进行优化提供了更好的机会。**

类似逻辑也应用于静态方法。

尽管当 **static** 作用于某个字段时，肯定会改变数据创建的方式（因为一个 **static** 字段对每个类来说都只有一份存储空间，而非 **static** 字段则是对每个对象有一个存储空间），但是如果 **static** 作用于某个方法，差别却没有那么大。**static** 方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。正如我们将会看到的那样，这一点对定义 **main()** 方法很重要，这个方法是运行一个应用时的入口点。

和其他任何方法一样，**static** 方法可以创建或使用与其类型相同的被命名对象，因此，**static** 方法常常拿来做 “牧羊人” 的角色，负责看护与其隶属同一类型的实例群。



## 2.7 你的第一个 Java 程序

有一个特定类会自动被导入到每一个 Java 文件中：java.lang。

### 2.7.1 编译和运行


## 2.8 注释和嵌入式文档

p32

### 2.8.1 注释文档

javadoc 便是用于提取注释的工具，它是 JDK 安装的一部分

### 2.8.2 语法

使用 Javadoc 的方式主要有两种：嵌入 HTML，或使用“文档标签”。<font face="楷书">独立文档标签</font>是一些以“@”字符开头的命令，且要置于注释行的最前面（但是不算前导 “\*” 之后的最前面）。而“行内文档标签”则可以出现在 javadoc 注释中的任何地方，它们也是以 “@” 字符开头，但要括在花括号里。

共有三中类型的注释文档，分别对应于注释位置后面的三种元素：类、域和方法。也就是说，类注释正好位于类定义之前；域注释正好位于域定义之前；而方法注释也正好位于方法定义的前面。例如：



```Java
//: object/Documentation1.java
/** A class comment */
public class Documentation1 {
  /** A field comment */
  public int i;
  /** A method comment */
  public void f() {}
} ///:~
```



注意，javadoc 只能为 **public**（公共）和 **protected**（受保护）成员进行文档注释。


### 2.8.3 嵌入式HTML

### 2.8.4 一些标签示例

### 2.8.5 文档示例



```Java
//: object/HelloDate.java
import java.util.*;

/** The first Thinking in Java example program.
 * Displays a string and today's data.
 * @author Bruce Eckel
 * @author www.MindView.net
 * @version 4.0
*/
public class HelloDate {
  /** Entry point to class & application.
   * @param args array of string arguments
   * @throws exceptions No exceptions thrown
  */
  public static void main(String[] args) {
    System.out.println("Hello，it’s: ");
    System.out.println(new Date());
  }
} /* Output: （55% match)
Hello，it's:
Wed Oct 05 14:39:36 MDT 2005
*///:~
```



第一行采用我自己独特的方法，用一个 “：” 作为特殊记号说明这是包含源文件名的注释行。该行包含文件的路径信息（此时，**object** 代表本章），随后是文件名。最后一行也是一行注释，这个 “///:~” 标志源代码清单的结束。自此，在通过编译器和执行检查后，文档就可以自动更新成本书的文本。

/* **Output** 标签表示输出的开始部分将由这个文件生成，通过这种形式，它会被自动地测试以验证其准确性。在本例中，（55% match 在向测试系统说明程序的每一次运行和下一次运行的输出存在着很大的差异，因此它们与这里列出的输出预期只有 55% 的相关性。）


## 2.9 编码风格

在 “Java 编程语言编码约定” 中，代码风格是这样规定的：类名的首字母要大写；如果类名由几个单词构成，那么把它们并在一起（也就是说，不要用下划线来分割名字），其中每个内部单词的首字母都采用大写形式。例如：



```Java
class AllTheColorsOfTheRainbow { // ...
```



这种风格有时称作“驼峰风格”。几乎其他所有内容 -- 方法、字段（成员变量）以及对象引用名称等，公认的风格与类的风格一样，<font face="">只是</font>标识符的第一个字母采用小写。例如：



```Java
class AllTheColorsOfTheRainbow {
  int anIntegerRepresentingColors;
  void changeTheHueOfTheColor(int newHue) {
    // ...
  }
  // ...
}
```



Sun 程序库中的 Java 代码也采用本书摆放开、闭花括号的方式。

end of chapter 2
