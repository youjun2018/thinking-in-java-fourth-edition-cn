
# 第3章 操作符

## 3.1 更简单的打印语句

import static

## 3.2 使用 Java 操作符

几乎所有的操作符都只能操作“基本类型”。例外的操作符是“=”、“==”和“!=”，这些操作符能操作所有的对象（这也是对象容易令人糊涂的地方）。除此之外，**String** 类支持“+”和“+=”。

## 3.3 优先级

所以应该用括号明确规定计算顺序。

## 3.4 赋值

对基本数据类型到的赋值是很简单的。

倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到另一个地方。这意味着假若对对象使用 **c=d**,那么 **c** 和 **d** 都指向原本只有 d 指向的那个对象。

这种特殊的现象通常称作“别名现象”，是 Java 操作对象的一种基本方式。

### 3.4.1 方法调用中的别名问题

将一个对象传递给方法时，也会产生别名问题：

## 3.5 算术操作符

整数除法会直接去掉结果的小数位，而不是四舍五入地圆整结果。

要生成数字，程序首先会创建一个 **Random** 类的对象。如果在创建的过程中没有传递任何参数，那么 Java 就会将当前时间作为随机数生成器的种子，并由此在程序每一次执行时都产生不同的输出。通过在创建 **Random** 对象时提供种子（用于随机数生成器的初始化值，随机数生成器对于特定的种子值总是产生相同的随机数序列），就可以在每一次执行程序时都生成相同的随机数，因此其输出是可验证的。

通过 **Random** 类的对象，程序可生成许多不同类型的随机数字。做法很简单，只需调用方法 **nextInt()** 和 **nextFloat()** 即可（也可以调用 **nextLong()** 或者 **nextDouble()**）。传递给 **nextInt()** 的参数设置了所产生的随机数的上限，而其下限为 0。

### 3.5.1 一元加、减操作符

一元减号（-）和一元加号（+）与二元减号和加号都使用相同的符号。

一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小类型的操作数提升为 **int**。

## 3.6 自动递增和递减

后缀递增和后缀递减  前缀递增和前缀递减


## 3.7 关系操作符

包括小于（<）、大于（>）、小于或等于（<=）、大于或等于（>=）、等于（==）以及不等于（!=）。等于和不等于适用于所有的基本数据类型，而其他比较符不适用于 **boolean** 类型。因为 **boolean** 值只能为 **true** 或 **false**，“大于”和“小于”没有实际意义。

### 3.7.1 测试对象的等价性

关系操作符==和!=也适用于所有对象，但这两个操作符通常会使第一次接触 Java 的程序员感到迷惑。

==和!=比较的就是对象的引用。

如果想比较两个对象的实际内容是否相同，必须使用所有对象都适用的特殊方法 **equals()**。但这个方法不适用于 “基本类型”，基本类型直接使用 == 和 != 即可。

除非在自己的新类中覆盖 **equals()** 方法，否则不可能表现出我们希望的行为。

大多数 Java 类库都实现了 **equals()** 方法，以便用来比较对象的内容，而非比较对象的引用。

## 3.8 逻辑操作符

逻辑操作符 “与”（&&）、“或”（||）、“非”（!）能根据参数的逻辑关系，生成一个布尔值（**true** 或 **false**）。

“与”、“或”、"非" 操作只可应用于布尔值。与在 C 及 C++ 中不同的是：Java 不可将一个非布尔值当作布尔值在逻辑表达式中使用。

注意，如果在应该使用 **String** 值的地方使用了布尔值，布尔值会自动转换成适当的文本形式。

### 3.8.1 短路

即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算。

## 3.9 直接常量

如果编译器不能准确地知道要生成什么样的类型，必须对编译器加以“指导”，用与直接量相关的某些字符来额外增加一些信息。

直接常量后面的后缀字符标志了它的类型。若为大写（或小写）的 **L**，代表 **long**（但是，使用小写字母 **l** 容易和数字 **1** 造成混淆）。大写（或小写）字母 **F**，代表 **float**；大写（或小写）字母 **D**，则代表 **double**。

十六进制数适用于所有整数数据类型，以前缀 **0x**（或 **0X**），后面跟随 **0-9** 或小写（或大写）的 **a-f** 来表示。如果试图将一个变量初始化成超出自身表示范围的值（无论这个值的数值形式如何），编译器都会向我们报告一条错误信息。如果超出范围，编译器会将值自动转化为 **int** 型，并告诉我们需要对这次赋值进行 “窄化转型”（转型将在本章稍后部分定义）。这样我们就可以清楚地知道自己的操作是否越界了。

八进制数由前缀 0 以及后续的 0~7 的数字来表示。

在 C、C++或者 Java 中，二进制数没有直接常量表示方法。但是，在使用十六进制和八进制记数法时，以二进制形式显示结果将非常有用。通过使用 **Integer** 和 **Long** 类的静态方法 **toBinaryString()** 可以很容易地实现这一点。请注意，如果将比较小的类型传递给 **Integer.toBinaryString()** 方法，则该类型将自动被转换为 int。

### 3.9.1 指数记数法

在科学与工程领域，“e” 代表自然对数的基数，约等于 2.718（Java 中的 **Math.E** 给出了更精确的 **double** 型的值）。在C、C++以及Java中， **$1.39e^{-43}f$** 时，它真正的含义是 $1.39 \times 10^{-43}$。

注意如果编译器能够正确地识别类型，就不必在数值后附加字符。例如语句



```
long n3 = 200;
```



它不存在含混不清的地方，所以200后面的 **L** 是用不着的。然而，对于语句



```
float f4 = 1e-43f;  // 10 to the power
```



编译器通常会将指数作为双精度数（double）处理，所以假定没有这个尾随的 **f**，就会收到一条出错提示，告诉我们必须适用类型转换将 **double** 转换成 **float**。

## 3.10 安位操作符

按位操作符用来操作整数基本数据类型中的单个“比特（bit）”，即二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。

“与”（&）   “或”（|）    “异或”（^）   “非”（~）

按位操作符和逻辑操作符都使用了同样的符号，因此我们能方便地记住他们的含义：由于位是非常“小”的，所以按位操作符仅使用了一个字符。

按位操作符可与等号（=）联合使用，以便合并运算和赋值：&=、|=和^=都是合法的（由于“~”是一元操作符，所以不可与“=”联合使用）。

我们将布尔类型作为一种单比特值对待，所以它多少有些独特。我们可对它执行按位“与”、按位“或”和按位“异或”运算，但不能执行按位"非"。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是它们不会中途“短路”。此外，针对布尔值进行的按位运算我们新增了一个“异或”逻辑操作符，它并未包括在“逻辑”操作符的列表中。在移位表达式中，不能使用布尔运算，原因将在后面解释。

## 3.11 移位操作符

移位操作符只可用来处理整数类型（基本类型的一种）。左移位操作符（<<）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。“有符号”右移位操作符（>>）则按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用 “符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java 中增加了一种“无符号”右移位操作符（>>>），它使用“零扩展”：无论正负，都在高位插入0。这一操作符是 C 或 C++ 中没有的。

如果是对 **char**、**byte** 或者 **short** 类型的数值进行移位处理，p50

“移位”可与“等号”（<<=或>>=或>>>=）组合使用。
“”
“”
“”

没看懂，有时间再看。


## 3.12 三元操作符 if-else

三元操作符也称为条件操作符，最终会生成一个值。与普通的 **if-else** 语句是不同的。其表达式如下：



```
boolean-exp ? value0 : value1
```



## 3.13 字符串操作符 + 和 +=

这个操作符在 Java 中有一项特殊用途：连接不同的字符串。

C++ 中引入了<font face="楷体">重载操作符</font>(operator overloading)机制。由于太过复杂，Java 程序员不能像 C++ 和 C# 程序员那样实现自己的重载操作符。

字符串操作符有一些很有趣的行为。如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串型。

```
int x = 0;
print("" + x);  // Shorthand for Integer.toString()
```

请注意，**main()** 中的最后一个示例：有时会看到这种一个空的 **String** 后面跟随+和一个基本类型变量，以此作为不调用更加麻烦的显式方法（在本例中应该是 **Integer.toString()**）而执行字符串转换的方式。

## 3.14 使用操作符时常犯的错误

即使对表达式如何计算有点不确定，也不愿意使用括号。


## 3.15 类型转换操作符

<font face="">类型转换</font>(cast) 的原意是 “模型铸造”。在适当的时候，Java 会将一种数据类型自动转换成另一种。

想要执行类型转换，需要将希望得到的数据类型置于圆括号内，放在要进行类型转换的值的左边。

注意，这里可能会引入“多余的”转型，例如，编译器在必要的时候会自动进行 **int** 值到 **long** 值的提升。但是你仍然可以做这样 “多余的” 事，以提醒自己需要留意。

在 Java 中，类型转换是一种比较安全的操作。然而，如果要执行一种名为<font face="">窄化转换</font>(narrowing conversion)的操作（也就是说将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型），就有可能面临信息丢失的危险。此时编译器会强制我们进行类型转换，必须显式地进行类型转换。对于<font face="">扩展转换</font>(widening conversion)，则不必显式地进行类型转换，不会造成任何信息的丢失。

Java 允许我们把任何基本数据类型转换成别的基本数据类型，但布尔型除外，后者根本不允许进行任何类型的转换处理。“类”数据类型不允许进行类型转换。为了将一种类型转换成另一种必须采用特殊的方法。

### 3.15.1 截尾和舍入

在执行窄化转换时，必须注意截尾与舍入问题。

将 **float** 或 **double** 转型为整型值时，总是对该数字执行截尾。如果要得到舍入的结果，就需要使用 **java.lang.Math** 中的 **round()** 方法，"Math.round(value);"。

由于 **round()** 是 **java.lang** 的一部分，因此在使用它时不需要额外地导入。

### 3.15.2 提升

如果对基本数据类型执行算术运算或按位运算，只要类型比 **int** 小（即 **char**、**byte** 或者 **short**），那么在运算之前，这些值会自动转换成 int。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。

## 3.16 Java没有sizeof

在C和C++中，**sizeof()** 操作符可以告诉你数据项分配的字节数。在C和C++中，需要使用 **sizeof()** 的最大原因是为了 “移植”。

Java 不需要 **sizeof()** 操作符来满足这方面的需要，因为所有数据类型在所有机器中的大小都是相同的。我们不必考虑移植问题--他已经被设计在语言中了。 


































end of chapter3
